

import marshal
from zlib import decompress
from invenio.dbquery import run_sql
from invenio.search_engine import perform_request_search
from invenio.intbitset import intbitset
from invenio.bibrank_citation_searcher import get_citation_dict


#Fetch dictionary


def standard_run():
    d = get_citation_dict('citationdict')
    generate_topcite_list(d,"year:2005->2009 -year:0->2004",100,'980:CORE year:"2005->2009" -year:"0->2004"',of='hb',num=100,outfile='last5_core.html')
    generate_topcite_list(d,"cited:100->9999999",100,"980:CORE",of='hb',num=100,outfile='all_core.html')
    generate_topcite_list(d,"cited:50->999999",50,"980:CORE year:'2009'",of='hb',num=100,outfile='all_core09.html')
    generate_topcite_list(d,'cited:50->999999 year:"2005->2009" -year:"0->2004"',50,"980:CORE  year:'2009'",num=100,of='hb',outfile='last5_core09.html')

    generate_topcite_list(d,"cited:50->999999",50,"year:'2009'",of='hb',num=100,outfile='all_09.html')
    generate_topcite_list(d,"cited:100->9999999",100,of='hb',num=100,outfile='all.html')


def generate_topcite_list(dict, citeds, citedcut='0',citings="", of="", num="",
    allpdg=True, header="", footer="",outfile=""):
    """Generates a topcited list in format of using a given cite dict and
    cited and citing restrictions
    @param dict: an unpacked citation_dict (so we don't need to load it
    each time
    @param citeds: a search for the candidate papers for
    topcites (generated by intbitset(perform_request_search(p=<query>)))
    @param citings: a search for the citing papers
    for the analysis.  If empty, will use full set
    @param citedcut: cut off the cited pool at this minimu citecount (speed)
    @param of: if given, will generate a single string containing
    html-ized list of the list, ready to print to file  default is
    empty-meaning return a sorted list of tuplese
    @param num: cutoff list at this num.  Default empty
    @param allpdg:if truen(default) we will unify all PDG editions and
    show the most recent
    @param header: header for html output set to " " for blank, ""
    (default) will generate stock header
    @param footer: footer for html output set to " " for blank, ""
    (default) will generate stock footer
    @param outfile: file to write html output to
    """



    from invenio.intbitset import intbitset
    from invenio.search_engine import perform_request_search

    cited_set = intbitset(perform_request_search(p=citeds))

    # a blank sitings searhc will get the whole db, as we expect
    citing_set = intbitset(perform_request_search(p=citings))

    pdgnote=""
    if allpdg:
        from invenio.bibformat_engine import BibFormatObject
        # we have to count pdg separately to unify
        pdg = intbitset(perform_request_search(p="210:'RPP' -210:'section'"))
        pdg_counts = sum([len( intbitset(dict[p]) & citing_set ) for p in pdg])
        cited_set = cited_set - pdg
        pdg_recent = sorted([(a,BibFormatObject(a).field("773__y")) for a in pdg.tolist()],key=lambda p:int(p[1])).pop()[0]
        pdgnote = "<br />The PDG has been unified and the most recent is shown"


    if citedcut:
        cited_set = intbitset([p for p in cited_set if dict.has_key(p) and len(dict[p])>citedcut])

    counts = [(p,len( intbitset(dict[p]) & citing_set )) for p in cited_set]
    counts.append((pdg_recent, pdg_counts))

    counts.sort(key=lambda p: p[1], reverse=True)

    if num:
        counts = counts[:num-1]



    if of:
        from invenio.bibformat import format_record
        counts = [ (c[0],c[1],format_record(c[0],of)) for c in counts]

        if len(header) == 0:
            header =  """
            <html>
            <link rel="stylesheet" type="text/css" href="http://inspirebeta.net/img/invenio_inspire.css" />
            <body>
            <h1>Draft Version!!</h1>
            <p>Top Cited  articles from """
            header += citeds + " cited by " + citings + pdgnote + "</p><ol>"
        if len(footer) == 0:
            footer += "</ol></body></html>"

        out = header


        for c in counts:
            out += "<li>" + str(c[1]) + " core citations for:" + c[2] +  "<br /><hr /></li>"
        out += footer

        if outfile:
            outf = open(outfile,"w")
            outf.write(out)
            outf.close
            return(len(counts))
        return(out)
    return(counts)
